
import os
import glob
import re
import pandas as pd


# Function definition
def set_run_names(protocols):
    ''' For each protocol retrieve the associated run names '''
    runs = []
    for protocol in protocols.index:
        matrix_dir = protocols.loc[protocol]['matrixdir']
        prot_runs = []
        for f in glob.glob(matrix_dir+'/*.matrix'):
            prot_runs.append(re.sub('_\d+.matrix', '', os.path.basename(f),))
        runs.append(",".join(set(prot_runs)))
    protocols['runs'] = runs
    return protocols


def get_raw_matrix(wildcards):
    """ input function for rule conversion
        returns the hicpro raw matrix associated to a protocol-run-resolution
    """
    mdir = sampled_protocols.loc[(wildcards.sample, wildcards.protocol)]['matrixdir']
    matrix_file = wildcards.run + "_" + wildcards.resolution + ".matrix"
    return mdir + "/" + matrix_file


def get_bed_file(wildcards):
    """ input function for rule conversion
        returns the hicpro bed file associated to a protocol-run-resolution
    """
    mdir = sampled_protocols.loc[(wildcards.sample, wildcards.protocol)]['matrixdir']
    bed_file = wildcards.run + "_" + wildcards.resolution + "_abs.bed"
    return mdir + "/" + bed_file


def get_matrices(wildcards):
    """ input function for rule mergeprotocol
        returns list of the h5 matrices associated with a protocol-resolution
    """
    runs = sampled_protocols.loc[(wildcards.sample, wildcards.protocol)]['runs'].split(',')
    matrices = []
    for run in runs:
        m = run + "_" + wildcards.resolution + ".h5"
        m_path = os.path.join("hdf5", wildcards.sample, wildcards.protocol, m)
        matrices.append(m_path)
    return matrices


def get_merged_matrices(wildcards):
    """
        The list of all the matrices of a sample and a given resolution
    """
    matrices = []
    for prot in sampled_protocols['protocol']:
        if prot in sampled_protocols.loc[wildcards.sample]['protocol']:
            m_path = os.path.join("hdf5", wildcards.sample, prot, wildcards.resolution, "matrix.h5")
            matrices.append(m_path)
    return matrices


def get_samples_protocol(protocol):
    """
        Returns the list of samples that have the given protocol
        (all samples have the merged protocol)
    """
    if protocol == "merged":
        return samples
    else:
        return list(sampled_protocols[sampled_protocols['protocol']==protocol]['sample'])


configfile: "config.yaml"

sampled_protocols = pd.read_csv(config["sampled_protocols"], sep = "\t").set_index(["sample","protocol"], drop = False)

sampled_protocols = set_run_names(sampled_protocols)

chromosomes = config['chromosomes']
samples = config['samples']
resolutions = config['resolutions']
regions = config['regions']

# If protocols are defined in config, we use those, if not we use all + merged
if "protocols" in config:
    all_protocols = config['protocols']
else:
    all_protocols = list(set(sampled_protocols['protocol'])) + ['merged']

workdir: config['workdir']

wildcard_constraints:
    protocol="|".join(all_protocols),
    sample="|".join(samples),
    resolution="\d+",
    region="|".join(regions)


rule all:
    input:
        expand("{protocol}.done", protocol=all_protocols)


rule singleprotocol:
    input:
        lambda wildcards: expand("plots/{sample}/{protocol}/{resolution}/{region}_plot.png",
                                 sample=get_samples_protocol(wildcards.protocol),
                                 protocol=wildcards.protocol,
                                 resolution=resolutions,
                                 region=regions)
    output:
        "{protocol}.done"
    shell:
        "touch {output}"


rule conversion:
    input:
        raw = get_raw_matrix,
        bed = get_bed_file
    output:
        "hdf5/{sample}/{protocol}/{run}_{resolution}.h5"
    shell:
        "hicConvertFormat --matrices {input.raw} --bedFileHicpro {input.bed}"
        " --outFileName {output} --outputFormat h5 --inputFormat hicpro"

rule mergeprotocol:
    input:
        get_matrices
    output:
        "hdf5/{sample}/{protocol}/{resolution}/matrix.h5"
    shell:
        "hicSumMatrices --matrices  {input} --outFileName {output}"

rule merge:
    input:
        get_merged_matrices
    output:
        "hdf5/{sample}/{protocol}/{resolution}/matrix.h5"
    shell:
        "hicSumMatrices --matrices {input} --outFileName {output}"

rule adjust:
    input:
        "hdf5/{sample}/{protocol}/{resolution}/matrix.h5",
    output:
        "hdf5/{sample}/{protocol}/{resolution}/adjusted.h5"
    params:
        chromosomes = chromosomes
    shell:
        "hicAdjustMatrix --matrix {input} --outFileName {output} "
        " --chromosomes {params.chromosomes} --action keep ;"

rule normalize:
    input:
        "hdf5/{sample}/{protocol}/{resolution}/adjusted.h5"
    output:
        "hdf5/{sample}/{protocol}/{resolution}/normalized.h5"
    shell:
        "hicNormalize --matrices {input} --outFileName {output}"
        " --normalize smallest"

rule correct:
    input:
        "hdf5/{sample}/{protocol}/{resolution}/normalized.h5"
    output:
        "hdf5/{sample}/{protocol}/{resolution}/corrected.h5"
    shell:
        "hicCorrectMatrix correct --matrix {input} --outFileName {output}"

rule diagnostic:
    input:
        "hdf5/{sample}/{protocol}/{resolution}/{type}.h5"
    output:
        "hdf5/{sample}/{protocol}/{resolution}/{type}_diagnostic.png"
    shell:
        "hicCorrectMatrix diagnostic_plot -m {input} -o {output}"

rule plotMatrix:
    input:
        "hdf5/{sample}/{protocol}/{resolution}/corrected.h5"
    output:
        "plots/{sample}/{protocol}/{resolution}/{region}_plot.png"
    shell:
        "hicPlotMatrix --matrix {input} --outFileName {output} --region {wildcards.region} --log"
